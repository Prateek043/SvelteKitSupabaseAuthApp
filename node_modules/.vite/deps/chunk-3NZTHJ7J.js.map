{
  "version": 3,
  "sources": ["../../jose/dist/browser/runtime/webcrypto.js", "../../jose/dist/browser/lib/buffer_utils.js", "../../jose/dist/browser/runtime/base64url.js", "../../jose/dist/browser/util/errors.js", "../../jose/dist/browser/runtime/random.js", "../../jose/dist/browser/lib/is_object.js", "../../jose/dist/browser/jwe/flattened/encrypt.js", "../../jose/dist/browser/lib/secs.js", "../../jose/dist/browser/util/base64url.js", "../../jose/dist/browser/util/decode_jwt.js", "../../@supabase/auth-helpers-shared/src/adapters/NextAdapter.ts", "../../@supabase/auth-helpers-shared/src/adapters/NextMiddlewareAdapter.ts", "../../@supabase/auth-helpers-shared/src/adapters/SvelteKitAdapter.ts", "../../@supabase/auth-helpers-shared/src/utils/constants.ts", "../../@supabase/auth-helpers-shared/src/utils/jwt.ts", "../../@supabase/auth-helpers-shared/src/utils/cookies.ts", "../../@supabase/auth-helpers-shared/src/utils/errors.ts"],
  "sourcesContent": ["export default crypto;\nexport const isCryptoKey = (key) => key instanceof CryptoKey;\n", "import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n", "import { encoder, decoder } from '../lib/buffer_utils.js';\nexport const encodeBase64 = (input) => {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n};\nexport const encode = (input) => {\n    return encodeBase64(input).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\nexport const decodeBase64 = (encoded) => {\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const decode = (input) => {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch (_a) {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n};\n", "export class JOSEError extends Error {\n    constructor(message) {\n        var _a;\n        super(message);\n        this.code = 'ERR_JOSE_GENERIC';\n        this.name = this.constructor.name;\n        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);\n    }\n    static get code() {\n        return 'ERR_JOSE_GENERIC';\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n    static get code() {\n        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    }\n}\nexport class JWTExpired extends JOSEError {\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_EXPIRED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n    static get code() {\n        return 'ERR_JWT_EXPIRED';\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n    static get code() {\n        return 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n}\nexport class JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_NOT_SUPPORTED';\n    }\n    static get code() {\n        return 'ERR_JOSE_NOT_SUPPORTED';\n    }\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_DECRYPTION_FAILED';\n        this.message = 'decryption operation failed';\n    }\n    static get code() {\n        return 'ERR_JWE_DECRYPTION_FAILED';\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWE_INVALID';\n    }\n}\nexport class JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWS_INVALID';\n    }\n}\nexport class JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWT_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWT_INVALID';\n    }\n}\nexport class JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWK_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWK_INVALID';\n    }\n}\nexport class JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWKS_INVALID';\n    }\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_NO_MATCHING_KEY';\n        this.message = 'no applicable key found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_NO_MATCHING_KEY';\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n        this.message = 'multiple matching keys found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_TIMEOUT';\n        this.message = 'request timed out';\n    }\n    static get code() {\n        return 'ERR_JWKS_TIMEOUT';\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n        this.message = 'signature verification failed';\n    }\n    static get code() {\n        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    }\n}\n", "import crypto from './webcrypto.js';\nexport default crypto.getRandomValues.bind(crypto);\n", "function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n", "import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else {\n                    if (!this._protectedHeader) {\n                        this.setProtectedHeader(parameters);\n                    }\n                    else {\n                        this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                    }\n                }\n            }\n        }\n        this._iv || (this._iv = generateIv(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ;\n            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n            iv: base64url(this._iv),\n            tag: base64url(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n", "const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[1]);\n    const unit = matched[2].toLowerCase();\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            return Math.round(value);\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            return Math.round(value * minute);\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            return Math.round(value * hour);\n        case 'day':\n        case 'days':\n        case 'd':\n            return Math.round(value * day);\n        case 'week':\n        case 'weeks':\n        case 'w':\n            return Math.round(value * week);\n        default:\n            return Math.round(value * year);\n    }\n};\n", "import * as base64url from '../runtime/base64url.js';\nexport const encode = base64url.encode;\nexport const decode = base64url.decode;\n", "import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = base64url(payload);\n    }\n    catch (_a) {\n        throw new JWTInvalid('Failed to parse the base64url encoded payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch (_b) {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n", "import type { IncomingMessage, ServerResponse } from 'http';\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport type { NextApiRequestCookies } from 'next/dist/server/api-utils';\nimport type { RequestAdapter, ResponseAdapter } from './types';\n\ntype NextRequest =\n  | NextApiRequest\n  | (IncomingMessage & {\n      cookies: NextApiRequestCookies;\n    });\n\nexport class NextRequestAdapter implements RequestAdapter {\n  private req: NextRequest;\n  constructor(request: NextRequest) {\n    this.req = request;\n  }\n\n  setRequestCookie(name: string, value: string) {\n    this.req.cookies[name] = value;\n  }\n\n  getHeader(name: string) {\n    return this.req.headers[name];\n  }\n}\n\nexport class NextResponseAdapter implements ResponseAdapter {\n  private res: NextApiResponse | ServerResponse;\n  constructor(response: NextApiResponse | ServerResponse) {\n    this.res = response;\n  }\n\n  getHeader(name: string) {\n    return this.res.getHeader(name);\n  }\n\n  setHeader(name: string, value: string) {\n    this.res.setHeader(name, value);\n    return this;\n  }\n}\n", "import type { NextRequest, NextResponse } from 'next/server';\nimport type { RequestAdapter, ResponseAdapter } from './types';\n\nexport class NextRequestAdapter implements RequestAdapter {\n  private req: NextRequest;\n  constructor(request: NextRequest) {\n    this.req = request;\n  }\n\n  setRequestCookie(name: string, value: string) {\n    this.req.cookies.set(name, value);\n  }\n\n  getHeader(name: string) {\n    return this.req.headers.get(name);\n  }\n}\n\nexport class NextResponseAdapter implements ResponseAdapter {\n  private res: NextResponse;\n  constructor(response: NextResponse) {\n    this.res = response;\n  }\n\n  getHeader(name: string) {\n    return this.res.headers.get(name);\n  }\n\n  setHeader(name: string, value: string) {\n    this.res.headers.set(name, value);\n    return this;\n  }\n}\n", "import type { RequestAdapter, ResponseAdapter } from './types';\n\nexport class SvelteKitRequestAdapter implements RequestAdapter {\n  private req: Request;\n  constructor(request: Request) {\n    this.req = request;\n  }\n\n  setRequestCookie(name: string, value: string) {\n    this.req.headers.set('cookie', `${name}=${value}`);\n  }\n\n  getHeader(name: string) {\n    return this.req.headers.get(name);\n  }\n}\n\nexport class SvelteKitResponseAdapter implements ResponseAdapter {\n  private res: Response;\n  constructor(response: Response) {\n    this.res = response;\n  }\n\n  getHeader(name: string) {\n    return this.res.headers.get(name);\n  }\n\n  setHeader(name: string, value: string | string[]) {\n    if (Array.isArray(value)) {\n      value.forEach((val: string) => {\n        this.res.headers.append(name, val);\n      });\n    } else {\n      this.res.headers.set(name, value);\n    }\n    return this.res;\n  }\n}\n", "export const COOKIE_OPTIONS = {\n  name: 'sb',\n  lifetime: 7 * 24 * 60 * 60, // 7 days\n  domain: '',\n  path: '/',\n  sameSite: 'lax'\n};\n\nexport const TOKEN_REFRESH_MARGIN = 10; // in seconds\nexport const RETRY_INTERVAL = 2; // in hundred ms (initial retry after 200ms with exponential backoff)\nexport const MAX_RETRIES = 10;\nexport const ENDPOINT_PREFIX = '/api/auth';\n", "import { decodeJwt } from 'jose';\n\nexport const jwtDecoder = (jwt: string) => decodeJwt(jwt);\n", "import type { RequestAdapter, ResponseAdapter } from '../adapters/types';\n\ntype Cookie = {\n  name: string;\n  value: string;\n  maxAge: number;\n  domain?: string;\n  path?: string;\n  sameSite?: string;\n};\n\ninterface Objs {\n  [key: string]: string | null;\n}\n\nexport const parseCookie = (str: string | null) => {\n  if (!str) return {};\n\n  const decode = decodeURIComponent;\n\n  return str\n    .split(';')\n    .map((v) => v.split('='))\n    .reduce((acc: Objs, v) => {\n      const [key, val] = v;\n      acc[decode(key.trim())] = decode(val.trim());\n      return acc;\n    }, {});\n};\n\n/**\n * Serialize data into a cookie header.\n */\nfunction serialize(\n  name: string,\n  val: string,\n  options: {\n    maxAge: number;\n    domain: string;\n    path: string;\n    expires: Date;\n    httpOnly: boolean;\n    secure: boolean;\n    sameSite: string;\n  }\n) {\n  const opt = options || {};\n  const enc = encodeURIComponent;\n  /* eslint-disable-next-line no-control-regex */\n  const fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  const value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  let str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    const maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid');\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    const sameSite =\n      typeof opt.sameSite === 'string'\n        ? opt.sameSite.toLowerCase()\n        : opt.sameSite;\n\n    switch (sameSite) {\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * Based on the environment and the request we know if a secure cookie can be set.\n */\nfunction isSecureEnvironment(req: RequestAdapter) {\n  if (!req || !req.getHeader('host')) {\n    throw new Error('The \"host\" request header is not available');\n  }\n\n  const headerHost = req.getHeader('host') as string;\n  const host =\n    (headerHost.indexOf(':') > -1 && headerHost.split(':')[0]) || headerHost;\n  if (\n    ['localhost', '127.0.0.1'].indexOf(host) > -1 ||\n    host.endsWith('.local')\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Serialize a cookie to a string.\n */\nfunction serializeCookie(cookie: Cookie, secure: boolean) {\n  return serialize(cookie.name, cookie.value, {\n    maxAge: cookie.maxAge,\n    expires: new Date(Date.now() + cookie.maxAge * 1000),\n    httpOnly: true,\n    secure,\n    path: cookie.path ?? '/',\n    domain: cookie.domain ?? '',\n    sameSite: cookie.sameSite ?? 'lax'\n  });\n}\n\n/**\n * Get Cookie Header strings.\n */\nexport function getCookieString(\n  req: RequestAdapter,\n  res: ResponseAdapter,\n  cookies: Array<Cookie>\n): string[] {\n  const strCookies = cookies.map((c) =>\n    serializeCookie(c, isSecureEnvironment(req))\n  );\n  const previousCookies = res.getHeader('Set-Cookie');\n  if (previousCookies) {\n    if (previousCookies instanceof Array) {\n      Array.prototype.push.apply(strCookies, previousCookies);\n    } else if (typeof previousCookies === 'string') {\n      strCookies.push(previousCookies);\n    }\n  }\n  return strCookies;\n}\n\n/**\n * Set one or more cookies.\n */\nexport function setCookies(\n  req: RequestAdapter,\n  res: ResponseAdapter,\n  cookies: Array<Cookie>\n) {\n  for (let cookie of cookies) {\n    req.setRequestCookie(cookie.name, cookie.value);\n  }\n  res.setHeader('Set-Cookie', getCookieString(req, res, cookies));\n}\n\n/**\n * Set one or more cookies.\n */\nexport function setCookie(\n  req: RequestAdapter,\n  res: ResponseAdapter,\n  cookie: Cookie\n) {\n  setCookies(req, res, [cookie]);\n}\n\nexport function deleteCookie(\n  req: RequestAdapter,\n  res: ResponseAdapter,\n  name: string\n) {\n  setCookie(req, res, {\n    name,\n    value: '',\n    maxAge: -1\n  });\n}\n", "export interface ErrorPayload {\n  type?: string;\n  message: string;\n  source?: string;\n}\n\nexport class AuthHelperError extends Error {\n  errorType: string;\n  source: string;\n\n  constructor(message: string, errorType: string) {\n    super(message);\n    this.errorType = errorType;\n    this.source = 'sb_auth_helpers';\n  }\n\n  toObj(): ErrorPayload {\n    return {\n      type: this.errorType,\n      message: this.message,\n      source: this.source\n    };\n  }\n\n  toString() {\n    return JSON.stringify(this.toObj());\n  }\n}\n\nexport class CookieNotFound extends AuthHelperError {\n  constructor() {\n    super('No cookie was found!', 'cookie_not_found');\n  }\n}\n\nexport class CookieNotSaved extends AuthHelperError {\n  constructor() {\n    super('Cookies cannot be saved!', 'cookie_not_saved');\n  }\n}\n\nexport class AccessTokenNotFound extends AuthHelperError {\n  constructor() {\n    super('No access token was found!', 'cookie_not_found');\n  }\n}\n\nexport class RefreshTokenNotFound extends AuthHelperError {\n  constructor() {\n    super('No refresh token was found!', 'cookie_not_found');\n  }\n}\n\nexport class ProviderTokenNotFound extends AuthHelperError {\n  constructor() {\n    super('No provider token was found!', 'cookie_not_found');\n  }\n}\n\nexport class CookieNotParsed extends AuthHelperError {\n  constructor() {\n    super('Not able to parse cookies!', 'cookie_not_parsed');\n  }\n}\n\nexport class CallbackUrlFailed extends AuthHelperError {\n  constructor(callbackUrl: string) {\n    super(`The request to ${callbackUrl} failed!`, 'callback_url_failed');\n  }\n}\n\nexport class JWTPayloadFailed extends AuthHelperError {\n  constructor() {\n    super('Not able to parse JWT payload!', 'jwt_payload_failed');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
