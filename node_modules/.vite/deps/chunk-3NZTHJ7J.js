// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;

// node_modules/jose/dist/browser/runtime/base64url.js
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (_a) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
var JOSEError = class extends Error {
  constructor(message) {
    var _a;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
  }
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
};
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
};

// node_modules/jose/dist/browser/runtime/random.js
var random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected = Symbol();

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;

// node_modules/jose/dist/browser/util/base64url.js
var decode2 = decode;

// node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch (_a) {
    throw new JWTInvalid("Failed to parse the base64url encoded payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch (_b) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}

// node_modules/@supabase/auth-helpers-shared/dist/index.mjs
var NextRequestAdapter = class {
  constructor(request) {
    this.req = request;
  }
  setRequestCookie(name, value) {
    this.req.cookies[name] = value;
  }
  getHeader(name) {
    return this.req.headers[name];
  }
};
var NextResponseAdapter = class {
  constructor(response) {
    this.res = response;
  }
  getHeader(name) {
    return this.res.getHeader(name);
  }
  setHeader(name, value) {
    this.res.setHeader(name, value);
    return this;
  }
};
var NextRequestAdapter2 = class {
  constructor(request) {
    this.req = request;
  }
  setRequestCookie(name, value) {
    this.req.cookies.set(name, value);
  }
  getHeader(name) {
    return this.req.headers.get(name);
  }
};
var NextResponseAdapter2 = class {
  constructor(response) {
    this.res = response;
  }
  getHeader(name) {
    return this.res.headers.get(name);
  }
  setHeader(name, value) {
    this.res.headers.set(name, value);
    return this;
  }
};
var SvelteKitRequestAdapter = class {
  constructor(request) {
    this.req = request;
  }
  setRequestCookie(name, value) {
    this.req.headers.set("cookie", `${name}=${value}`);
  }
  getHeader(name) {
    return this.req.headers.get(name);
  }
};
var SvelteKitResponseAdapter = class {
  constructor(response) {
    this.res = response;
  }
  getHeader(name) {
    return this.res.headers.get(name);
  }
  setHeader(name, value) {
    if (Array.isArray(value)) {
      value.forEach((val) => {
        this.res.headers.append(name, val);
      });
    } else {
      this.res.headers.set(name, value);
    }
    return this.res;
  }
};
var COOKIE_OPTIONS = {
  name: "sb",
  lifetime: 7 * 24 * 60 * 60,
  domain: "",
  path: "/",
  sameSite: "lax"
};
var TOKEN_REFRESH_MARGIN = 10;
var RETRY_INTERVAL = 2;
var MAX_RETRIES = 10;
var ENDPOINT_PREFIX = "/api/auth";
var jwtDecoder = (jwt) => decodeJwt(jwt);
var parseCookie = (str) => {
  if (!str)
    return {};
  const decode3 = decodeURIComponent;
  return str.split(";").map((v) => v.split("=")).reduce((acc, v) => {
    const [key, val] = v;
    acc[decode3(key.trim())] = decode3(val.trim());
    return acc;
  }, {});
};
function serialize(name, val, options) {
  const opt = options || {};
  const enc = encodeURIComponent;
  const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  const value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  let str = name + "=" + value;
  if (opt.maxAge != null) {
    const maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function isSecureEnvironment(req) {
  if (!req || !req.getHeader("host")) {
    throw new Error('The "host" request header is not available');
  }
  const headerHost = req.getHeader("host");
  const host = headerHost.indexOf(":") > -1 && headerHost.split(":")[0] || headerHost;
  if (["localhost", "127.0.0.1"].indexOf(host) > -1 || host.endsWith(".local")) {
    return false;
  }
  return true;
}
function serializeCookie(cookie, secure) {
  var _a, _b, _c;
  return serialize(cookie.name, cookie.value, {
    maxAge: cookie.maxAge,
    expires: new Date(Date.now() + cookie.maxAge * 1e3),
    httpOnly: true,
    secure,
    path: (_a = cookie.path) != null ? _a : "/",
    domain: (_b = cookie.domain) != null ? _b : "",
    sameSite: (_c = cookie.sameSite) != null ? _c : "lax"
  });
}
function getCookieString(req, res, cookies) {
  const strCookies = cookies.map((c) => serializeCookie(c, isSecureEnvironment(req)));
  const previousCookies = res.getHeader("Set-Cookie");
  if (previousCookies) {
    if (previousCookies instanceof Array) {
      Array.prototype.push.apply(strCookies, previousCookies);
    } else if (typeof previousCookies === "string") {
      strCookies.push(previousCookies);
    }
  }
  return strCookies;
}
function setCookies(req, res, cookies) {
  for (let cookie of cookies) {
    req.setRequestCookie(cookie.name, cookie.value);
  }
  res.setHeader("Set-Cookie", getCookieString(req, res, cookies));
}
function setCookie(req, res, cookie) {
  setCookies(req, res, [cookie]);
}
function deleteCookie(req, res, name) {
  setCookie(req, res, {
    name,
    value: "",
    maxAge: -1
  });
}
var AuthHelperError = class extends Error {
  constructor(message, errorType) {
    super(message);
    this.errorType = errorType;
    this.source = "sb_auth_helpers";
  }
  toObj() {
    return {
      type: this.errorType,
      message: this.message,
      source: this.source
    };
  }
  toString() {
    return JSON.stringify(this.toObj());
  }
};
var CookieNotFound = class extends AuthHelperError {
  constructor() {
    super("No cookie was found!", "cookie_not_found");
  }
};
var CookieNotSaved = class extends AuthHelperError {
  constructor() {
    super("Cookies cannot be saved!", "cookie_not_saved");
  }
};
var AccessTokenNotFound = class extends AuthHelperError {
  constructor() {
    super("No access token was found!", "cookie_not_found");
  }
};
var RefreshTokenNotFound = class extends AuthHelperError {
  constructor() {
    super("No refresh token was found!", "cookie_not_found");
  }
};
var ProviderTokenNotFound = class extends AuthHelperError {
  constructor() {
    super("No provider token was found!", "cookie_not_found");
  }
};
var CookieNotParsed = class extends AuthHelperError {
  constructor() {
    super("Not able to parse cookies!", "cookie_not_parsed");
  }
};
var CallbackUrlFailed = class extends AuthHelperError {
  constructor(callbackUrl) {
    super(`The request to ${callbackUrl} failed!`, "callback_url_failed");
  }
};
var JWTPayloadFailed = class extends AuthHelperError {
  constructor() {
    super("Not able to parse JWT payload!", "jwt_payload_failed");
  }
};

export {
  NextRequestAdapter,
  NextResponseAdapter,
  NextRequestAdapter2,
  NextResponseAdapter2,
  SvelteKitRequestAdapter,
  SvelteKitResponseAdapter,
  COOKIE_OPTIONS,
  TOKEN_REFRESH_MARGIN,
  RETRY_INTERVAL,
  MAX_RETRIES,
  ENDPOINT_PREFIX,
  jwtDecoder,
  parseCookie,
  setCookies,
  setCookie,
  deleteCookie,
  AuthHelperError,
  CookieNotFound,
  CookieNotSaved,
  AccessTokenNotFound,
  RefreshTokenNotFound,
  ProviderTokenNotFound,
  CookieNotParsed,
  CallbackUrlFailed,
  JWTPayloadFailed
};
//# sourceMappingURL=chunk-3NZTHJ7J.js.map
